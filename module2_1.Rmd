---
title: "Module 2.1"
author: "Getting started: basic programming (P. Williams)"
date: "September 2018"
output: 
  html_document: 
    theme: journal
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

```{r echo=FALSE}


##################################################
####                                          ####  
####  R Bootcamp #2, Module 1                 ####
####                                          #### 
####   University of Nevada, Reno             ####
####                                          #### 
##################################################

## NOTE: this module borrows heavily from an R short-course developed by a team at Colorado State University. 
   # Thanks to Perry Williams for allowing us to use these materials!!

##########################################
####  PROGRAMMING: FUNCTIONS AND MORE ####
##########################################


```

NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University. 
    
**Guest presenter**: Perry Williams (who also pulled this module together, and was a part of the CSU team that put many of these materials toghether and graciously allowed us to borrow them- thanks!!!)

## Load script for module #2.1

1. Click [here](module2_1.R) to download the script! Save the script to a convenient folder on your laptop.

2. Load your script in RStudio. To do this, open RStudio and click on the folder icon in the toolbar at the top and load your script. 

Let's get started with basic programming  in R!


## Functions in R

Everything in R can be boiled down to this one sentence: data are expressed as *vectors*, and vectors are managed, manipulated, and visualized via **functions**. Functions are absolutely central to R!

Let's start with a blank workspace: 

```{r}

#######
# Start with blank workspace

rm(list=ls())


```

As we have seen, base R already includes lots of functions, and thousands more functions are available in packages that you can install. Nonetheless, it's really useful to know how to write your own functions! For example, we might write our own function if we have to repeat certain sets of operations over and over in different contexts. 

We use the following syntax when we are writing our own functions:

```

my.function <- function(inputs){         # function takes various arguments, or inputs
    
    ## Algorithm: Do something useful with the inputs
    
    return(output)             # optionally, return some output
    
}

```

### First function: "Hello, world!"

Let's try to write our first function, which prints out a message: "Hello, world!"

```{r}

####
####  Functions
####

my.function = function(){       # this function has no arguments
  message <- "Hello, world!"
  print(message)
}

```


Now we can run the function!

```{r}

my.function()

```

### 'Mean' function

Let's write a function to compute the mean of a vector. Okay fine, base R already has the "mean()" function, but let's do it anyway!

```{r}

## We can write our own functions. Useful if we have to repeat operations over and over.
my.mean <- function(x){
    m <- sum(x)/length(x)
    return(m)
}

foo <- c(2, 4, 6, 8)
my.mean(foo)


```

### 'Square' function

How about a function to square the arguments?

```{r}

## A function to square the arguments.
square <- function(x){
    x^2
}

## Square a single value (scaler).
square(2)

## Square a vector.
square(1:10)


```

### 'Logit' function

The logit operation (log-odds) is not included in the base R package. Let's write it ourselves!

```{r}

## Often, we need to write functions that are not included in the base R package e.g., the logit function.
## Calculate the log-odds (logit).
logit <- function(x){
    log(x/(1-x))
}

## Calculate logit of 0.9.
logit(.9)

## Sequence between 0 and 1.
x <- seq(from = 0, to = 1, by = 0.01)

## Caclulate the logit of a vector.
logit.x <- logit(x)
logit.x

## Plot x on x-axis, and logit(x) on y axis.
par(mfrow = c(1, 1))
plot(x, logit.x, type = 'l')    # View the output graphically.

```

### 'Expit' function

A useful, related function is the inverse-logit, or "expit" function:

```{r}

## The expit (or inverse logit) funtion.
expit <- function(x){
    exp(x)/(1+exp(x))
}

## Calculate the inverse-logit of logit(0.9) = 2.197225.
expit(2.197225)

expit.logit.x <- expit(logit.x)    # Return to original x values.

## Plot x on x-axis, and expit(logit(x)) = x on y axis.
plot(x, expit.logit.x, type = 'l')

## Plot "logistic" curve
plot(x=seq(-3,3,0.1),y=expit(seq(-3,3,0.1)),type="l")


```

### Kaplan Meier survival function

Finally, let's develop a function to compute the maximum-likelihood estimator for a Kaplan-Meier survival analysis:

```{r}

## Kaplan Meier known-fate maximum likelihood estimator.
survival.mle <- function(n, d){
    (n-d)/n
}
## n is the number of animals fitted with ratio transmitters being monitored.
## d is the number of n that died.

## One year of data.
survival.mle(n = 10, d = 5)

## Many years of data.
d <- sample(0:50, 10, replace = TRUE)
n <- c(100, 100-d)
(surv <- survival.mle(n = n[1:10], d = d))

## Plot year-specific survival rate.
plot(1:10, surv, type = 'l')

```


## Conditional statements 

Conditional, or logical, operations (IF [condition] THEN [do something] ELSE [do something]) are a basic building block of computer programming. 

### if...else statements in R

The basic syntax for if...else statements in R is as follows:

```

if([some condition]){               ## if some condition is met
  [execute some commands]
}else if ([some other condition]){   ## if some other condition is met
  [execute some other commands]
}else{                               ## if none of the above conditions are met
  [execute some other commands]
}

```

Let's try it!

```{r}

####
####  if...else statements
####

########
# Draw a sample from a Binomial distribution with p = 0.7 (here, p is detection probability).
n.samples <- 1
p <- 0.7
x <- rbinom(n = n.samples, size = 1, prob = p)

if (x > 0) {
    print("Detected")
} else {
    print("Not detected")
}


```

### ifelse() function

Note that "if...else" only works for testing one value. If we have a spreadsheet with lots of data, need something else -- like the "ifelse()" function.

```{r}

####
####  ifelse()
####

## Note if...else only works for testing one value. If we have a spreadsheet with lots of data, need something else.
n.samples <- 100
set.seed(2017)

## 100 samples from a binomial disribution with detection probability = p = 0.7.
y <- rbinom(n = n.samples, size = 1, prob = p)
y

## incorrect usage
if (y == 1) {
    print("Detected")
} else {
    print("Not detected")
}   # PRINTS A WARNING MESSAGE!

## Use ifelse instead.
detection.history <- ifelse(y == 1, print("Detected"), print("Not detected"))
detection.history

## Going the other direction.
ifelse(detection.history == "Detected", 1, 0)

xt  <-  cbind(rbinom(10, 1, .5), rbinom(10, 1, .6))
xt
ifelse(xt[, 1] > 0 & xt[, 2] > 0, print("Detected twice"),
       print("Not detected twice"))


```


## Iterating!

Iterating, or running the same operation over and over sequentially, is another fundamental computer programming tool. Computers are great at performing multiple computations really, really fast! **Loops** are a good way to take advantage of computers! 

The basic syntax for iterating in R is called a "FOR loop", and looks like this:

```

for([placeholder variable] in [iteration vector of length x]){
  [perform specified operation(s) x times, with the placeholder variable alternately set at each value of the iteration vector]
}

```

For example... 

```{r}

####
####  for loops
####

n.iter <- 10
count <- 0
for(i in 1:n.iter){
    count <- count+1            # assign a new value of count equal to the old value of count + 1
    print(count)
}


```


Here, "i" is the placeholder variable and "1:n.iter" is the iteration vector: 

```{r}

  # closer look at iteration vector:
1:n.iter

```


Essentially, R starts this for loop by setting the value of the placeholder variable "i" to the first value of  (1). It then runs the two commands in the body of the for loop [count <- count+1; print(count)]. Then, it sets the placeholder variable "i" to the next value in the iteration vector (2) and runs the commands again. It keeps doing this until it reaches the end of the iteration vector, at which point it stops!  



Often, we use the placeholder variable directly within the for loop. Here are some examples:

```{r}

## Using the placeholder variable "i" within the for loop:

count <- 0
for(i in 1:n.iter){
    count <- count+i            # assign a new value of count equal to the old value of count + i
    print(count)
}

## A for-loop for dependent sequence (here, the Fibonacci sequence)
n.iter <- 10
x <- rep(0, n.iter)            # set up vector of all zeros
x[1] <- 1                     # assign x_1  <-  1
x[2] <- 1                     # assign x_2 = 0
x

for(i in 3:n.iter){
    x[i] <- x[i-1]+x[i-2]       # x_i = x_(i-1) + x_(i-2)
}
x


```


### Iterating using the "apply() family of functions in R"

```{r}

###
### apply
###

W <- matrix(rpois(4, 10), nrow = 2, ncol = 2)  # Create a 2X2 matrix using a Poisson distribution with lambda = 10.
W

## Calculate the row means.
apply(W, 1, mean)

## Calculate the column means.
apply(W, 2, mean)

## Identify the column that has the largest value.
apply(W, 1, which.max)

## Apply your own functions to each row in a matrix.
MyFunc <- function(x){
    2+sum(x/5)-3/2*mean(x)^2
}
apply(W, 1, MyFunc)


```


```{r}
####################
####  Exercises ####
####################

## if...else
## Reject or fail to reject a null hypothesis.
n.samples <- 100
x <- rnorm(n = n.samples, mean = 1, sd = 1) # Sample from a normal distribution.
mu <- mean(x)                               # Sample mean.
s <- sd(x)                                  # Sample standard deviation.
t <- mu/(s/sqrt(n.samples))                 # Calculate t-statistic.
t.crit <- qt(p = 0.975, df = 99)            # Calculate critical value for test.
if (t > t.crit) {
    print("reject")                        # Reject if condition holds.
} else {
    print("fail to reject")                # Fail to reject otherwise.
}

###
### Clean up messy matrix using ifelse
###

## Simulate data.
observations <- matrix(sample(c("Detected", "NotDetected", 1, 0), 20*3, replace = TRUE), 20, 3)
habitat <- rnorm(20, 0, 2)
Data <- cbind(observations, habitat)
Data

## Clean-up data
NewObs <- ifelse(Data[, 1:3] == "Detected"|Data[, 1:3] == "1", 1, 0) #  The "|" means "or." Similarly "&" means "and"
NewHabitat <- as.numeric(Data[, 4])  # as.numeric gets rid of quotes around habitat data.
NewHabitat <- round(NewHabitat, 2)   # round rounds to number of decimals specified.
NewData <- cbind(NewObs, NewHabitat) # bind the columns to form a matrix.
colnames(NewData) <- c("obs1", "obs2", "obs3", "Habitat")  # provide column names
NewData

###
### for loop
###

## Plot a 3D surface using data already stored in R.
Z <- 2 * volcano        # Exaggerate the relief
X <- 10 * (1:nrow(Z))   # 10 meter spacing (S to N)
Y <- 10 * (1:ncol(Z))   # 10 meter spacing (E to W)
Z
par(mfrow = c(2,1), bg = "white")
persp(X,  Y, Z, theta = 135, phi = 30, col = "green3",
      scale = FALSE, ltheta = -120, shade = 0.75,
      border = NA, box = FALSE)

## change the value of theta from 135 to 90 to change the viewing angle
persp(X, Y, Z, theta = 90, phi = 30, col = "green3",
      scale = FALSE,  ltheta = -120, shade = 0.75,
      border = NA, box = FALSE)

## Use a for-loop to help view many angles.
par(mfrow = c(1,1))
for(i in 1:18){
    persp(X, Y, Z, theta = i*20, phi = 30, col = "green3",
          scale = FALSE,  ltheta = -120, shade = 0.75,
          border = NA, box = FALSE)
    print(i*20)
    readline()                               # Pauses the for-loop until [enter] is pushed
}

## Use a for-loop to create a simulation to test the central limit theorem.
n.iter <- 1000                                # 1000 hypothetical "repeat samples."
sample.size <- 30                             # Sample size of 30 from each repeat sample.
mu <- 5                                       # True population mean of 5.
sd <- 2                                       # True standard deviation of 2.
means <- numeric(n.iter)                      # Empty vector to store the sample means.
for(i in 1:n.iter){                        # For each of the repeat samples, calculate and
    sample <- rnorm(sample.size, mean = mu, sd = sd)  # store the mean.
    means[i] <- mean(sample)
}
hist(means)                                # Histogram of all the means.
abline(v = mean(means), col = 2, lwd = 4)          # The mean of the means is close to the true mean of 5.
plot(density(means), main = "")
abline(v = mean(means), col = 2, lwd = 4)
mean(means)                                # Close to true mean of 5
sd(means)*sqrt(30)                         # Close to true sd of 2

## Logistic growth function.
logistic.growth <- function(r, P0, K){          # A function to calculate population
    dpdt <- r*P0*(1-P0/K)                       # size using logistic growth model.
    P0+dpdt                                  # r = intrinsic growth rate, P0 = initial population size,
}                                          # K = carrying capacity.
logistic.growth(r = .5, P0 = 10, K = 100)

## Logistic growth function within a for-loop
years <- 20                                   # How many years we want to calc population size.
pop.size <- numeric(years)                    # Empty vector to store population size.
pop.size[1] <- 5                              # Starting population size (P0).
for(i in 1:(years-1)){                     # Function within a for-loop.
    pop.size[i+1] <- logistic.growth(r = 0.5, P0 = pop.size[i], K = 100)
}
plot(1:years, pop.size, type = 'l',
     xlab = "Years", ylab = "Population Size")

## A more complex function that ouputs a plot.
plot.logistic.growth <- function(r, P, K, years){
    pop.size[1] <- P
    for(i in 1:(years-1)){
        pop.size[i+1] <- P+r*P*(1-P/K)
        P <- pop.size[i+1]
    }
    plot(1:years, pop.size, type = 'l', xlab = "Years",
         ylab = "Population Size",
         main = paste("r = ", r, "K = ", K))
}

plot.logistic.growth(r = 0.5, P = 10, K = 100, years = 20)
par(mfrow = c(2, 2), mar = c(4, 4, 1, 1))                  # Multi-figure (mf) plot with 2 rows and 2 columns.
plot.logistic.growth(r = 0.1, P = 10, K = 100, years = 20)   # Change the values of r and quickly print plots.
plot.logistic.growth(r = 0.2, P = 10, K = 100, years = 20)
plot.logistic.growth(r = 0.3, P = 10, K = 100, years = 20)
plot.logistic.growth(r = 0.5, P = 10, K = 100, years = 20)
par(mfrow = c(1, 1))                               # Return to a 1X1 plot.
```



## Challenge problems!

1: Create a function to calculate the value of y for the equation y = beta_0 + beta_1*x for any value of beta_0, beta_1 and x.


2: Using the function in 1, with beta_0 = 2, and beta_1= -1 use a for-loop to calculate y for the values of x = 1,...,10. Plot the results.


3: Write a function that conducts a two-sided t test for a given null hypothesis.

```

get.t.test <- function(data, mu0, alpha = 0.05) {
    n <- length(data)
    mu <- mean(____)
    s <- ____(data)
    t <- (mu-mu0)/(s/sqrt(n))
    t.crit <- qt(p = (1-alpha/2), df = n-1)        # get the critical value
    if (abs(t)>t.crit) {
        answer = "_______"
    } ____ {
        answer = "Fail to reject"
    }
    print(answer)
}

```

4: Calculate the standard deviation as an index of ruggedness from the rows of the volcano elevation data "Z", using the apply function. Which row has the most rugged terrain?


5: Wrap the code below in a for loop to simulate the sun rising and setting over the volcano data by looping over values of "lphi" (the light angle). Try replacing "readline()" with "Sys.sleep(.5)" from the example above.


```
persp(X, Y, Z, theta = 30, phi = 30, col = "green3",  lphi = ?,
                                                          scale = FALSE,  ltheta = -120, shade = 0.75,
      border = NA, box = FALSE)
print(?)
readline()

```




[--go to next module--](module2_2.html)











