if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# ?read.csv
# ?readLines
# read.table with tab delimited file (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.tab.df <- read.table("data.dat", header=TRUE, sep="")
head(data.tab.df)    # display the first few lines of the data frame
# read.table to import textfile
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# ?names: lists names of an object (columns, name of list elements)
names(data.csv.df)
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove objects we won't be using
rm(data.tab.df)
rm(data.txt.df)
rm(data.csv.df)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 2                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
#########################
####  Managing data  ####
#########################
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will probably differ from yours!
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# ?read.csv
# ?readLines
# read.table with tab delimited file (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.tab.df <- read.table("data.dat", header=TRUE, sep="")
head(data.tab.df)    # display the first few lines of the data frame
# read.table to import textfile
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# ?names: lists names of an object (columns, name of list elements)
names(data.csv.df)
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove objects we won't be using
rm(data.tab.df)
rm(data.txt.df)
rm(data.csv.df)
# read built-in data on the passengers of the titanic
data(Titanic)
str(Titanic)    # examine the structure of this data object
####
#### Check/explore data object
####
# ?class: tells you what type of data object you have
class(data.df)
# ?str: displays the internal structure of the data object
str(data.df)
# ?head: displays first n elements of object (default=6)
head(data.df)
head(data.df,2)
# ?tail: displays last n elements of object (default=6)
tail(data.df)
####
#### Exporting data (save to hard drive as data file)
####
# ?write.table: writes a file to the working directory
# ?writeLines: writes to a file, one line at a time
write.table(data.df[,c("Country","Export")], file="data_export.csv", sep=",", col.names=TRUE, row.names=FALSE)   # export a subset of the data we just read in.
####
####  Saving and loading
####
# ?save: saves particular objects to hard disk
a <- 1
b <- data.df$Product
save(a,b,file="Module1_2.RData")
rm(a,b)   # remove these objects from the workspace
load("Module1_2.RData")   # load these objects back in!
save.image(file="Module2.RData")    # ?save.image: saves entire workspace
load(file="Module2.RData")  # load the workspace from the working directory
##############
# Clear the workspace (and load it back in!)
save.image(file="Module2.RData")    # ?save.image: saves entire workspace (we don't necessarily want to clear everything right now)
rm(list=ls())   # clear the entire workspace. Confirm that your workspace is now empty!
load(file="Module2.RData")   # load the objects back!
# <- assignment operator: required for functions
# =  alternative assignment operator
a <- 3     # assign the value "3" to the object "a"
a = 3      # assign the value "3" to the object "a"
a == 3     # answer the question: "does the object "a" equal "3"?
a == 2
####
####  Boolean operations
####
#####
# Basic operators
# <    less than
# >    greater than
# <=   less than or equal to
# >=   greater than or equal to
# ==   equal to
# !=   not equal to
# %in% matches one of a specified group of possibilities
#####
# Combining multiple conditions
# &    must meet both conditions (AND operator)
# |    must meet one of two conditions (OR operator)
Y <- 4
Z <- 6
Y == Z  #I am asking if Y is equal to Z, and it will return FALSE
Y < Z
# Wrong!
data.df[,2]=74     # sets entire second column equal to 74!
data.df <- read.csv("data.csv")  ## correct our mistake in the previous line and revert to the original data!
# Right
data.df[,2]==74    # tests each element of column to see whether it is equal to 74
####
####  Subsetting data
####
##########
# The "which()" function -- return indices of a vector that meet a certain condition (condition is TRUE)
which(data.df[,2]==74)       # elements of the data column that are equal to 74
which(data.df[,2]!=74)       # elements of the data column that are NOT equal to 74
which(data.df[,2]<74)        #  and so on...
which((data.df[,2]<74)|(data.df[,2]==91))   # use the OR operator
data.df[which(data.df[,2]<74),2]    # check to make sure these numbers are under 74- they had better be!
data.df[data.df[,2]<74,2]    # alternative syntax without using "which()"...
sub.countries<-c("Chile","Colombia","Mexico")    # create vector of character strings
which(data.df[,1]=="Chile")
which(data.df$Country=="Chile")
# This command doesn't work because sub.countries is a vector, not a single character string.
which (data.df[,1]==sub.countries)
# Instead we use %in%
which(data.df[,1] %in% sub.countries)     # elements of data column that match one or more of the elements in "sub.countries"
which((data.df[,1] %in% sub.countries) & (data.df[,4]=="N"))   # use AND operator
which((data.df$Country %in% sub.countries) & (data.df$Product=="N"))
# What if we don't want the row number, but the actual row(s) of data that meet a particular condition?
data.df[which(data.df$Country %in% sub.countries),]
####
####  Practice subsetting a data frame
####
turtles.df <- read.table(file="turtle_data.txt", header=T, stringsAsFactors = FALSE)
names(turtles.df)
head(turtles.df)
# Subset for females
fem.turtles.df <- turtles.df[which(turtles.df$sex =="female"),]
# Can subset just one factor based on another
# Here we want to know the mean weight of all females
mean(fem.turtles.df$weight)
mean(turtles.df$weight[which(turtles.df$sex =="female")])
# Using subset to correct data entry problems
unique(turtles.df$sex)
table(turtles.df$sex)   # do you notice the data entry problem here?
turtles.df[which(turtles.df$sex=="fem"),2]<-"female"            # recode the sex variable
# Try using the "subset()" function, which can make subsetting a data frame even easier!
female.turtles <- subset(turtles.df,sex=="female")              # use the "subset()" function!
female.turtles <- subset(turtles.df,sex!="male")                # alternative
female.turtles <- turtles.df[which(turtles.df$sex!="male"),]    # alternative
subset.turtles.df <- subset(turtles.df, weight >= 10)
head(subset.turtles.df)
# Subsetting to certain individuals
bad.tags <- c(13,105)
good.turtles.df <- turtles.df[!(turtles.df$tag_number %in% bad.tags),]
bad.turtles.df <- turtles.df[turtles.df$tag_number %in% bad.tags,]
bad.turtles.df
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
2L
typeof(2L)
typeof(2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
d.mat <- rbind(c(1,2,3),c(4,5,6))        # create matrix another way
d.mat
d.mat <- matrix(c(1,2,3,4,5,6),nrow=3,ncol=2,byrow=T)        # create matrix another way
d.mat
d.mat <- matrix(c(1,2,3,4,5,6),nrow=3,ncol=2)        # create matrix another way
d.mat
d.mat <- rbind(c(1,2,3),c(4,5,6))        # create matrix another way
d.mat
d.mat + 2
d.mat/sum(d.mat)
d.mat <- rbind(c(1,4),c(2,5),c(3,6))        # create matrix another way
d.mat
knitr::opts_chunk$set(echo = TRUE)
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
install.packages("RevoUtilsMath")
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript2("module1_1.Rmd")
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_5.Rmd")
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
data("Titanic")
head(Titanic)
data("Titanic")
head(Titanic)
data("Titanic")
?Titanic
mosaicplot(Titanic, main = "Survival on the Titanic")
str(Titanic)
data("mtcars")
head(mtcars)
data()
crimtab
airquality
ability.cov
USAccDeaths
Titanic
esoph
data(trees)
head(trees)
summary(trees)
str(trees)
hist(trees$Height)
layout(matrix(1:3,nrow=1,byrow = T))
hist(trees$Height)
layout(matrix(1:3,nrow=1,byrow = T))
hist(trees$Height)
hist(trees$Girth)
hist(trees$Volume)
pairs(trees)
plot(trees$Volume~trees$Girth)
plot(trees$Volume~trees$Height)
layout(matrix(1:2,nrow=1,byrow = T))
plot(trees$Volume~trees$Girth)
plot(trees$Volume~trees$Height)
model1 <- lm(Volume~Girth)
model1 <- lm(Volume~Girth,data=trees)
summary(model1)
trees$Girth
xvals <- seq(1,35,0.5)
ypred <- predict(model1,newdata=data.frame(Girth=xvals))
ypred
xvals <- seq(5,35,0.5)
ypred <- predict(model1,newdata=data.frame(Girth=xvals))
ypred
conf <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.05)
conf
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.05)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.05)
?trees
layout(matrix(1:2,nrow=1,byrow = T))
plot(trees$Volume~trees$Girth)
plot(trees$Volume~trees$Height)
plot(trees$Volume~trees$Girth)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Volume=f(Girth), Black Cherry",
xlim=range(xvals),ylim=c(0,100))
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1)
abline(model1,lwd=2,col="green")
pred[,"upr"]
#########
# visualize the results!
xvals <- seq(5,35,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.05)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
pred[,"upr"]
xvals
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
points(xvals,pred[,"lwr"],col="green",lty=2)
pred
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.95)
#########
# visualize the results!
xvals <- seq(5,35,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.95)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
#########
# visualize the results!
xvals <- seq(5,35,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
#########
# visualize the results!
xvals <- seq(5,30,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
coefficients(model1)
#########
# visualize the results!
xvals <- seq(5,30,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
text(10,80,sprintf("Volume = %s + %s*Girth",coefficients(model1)[1,coefficients(model1)[2]))
#########
# visualize the results!
xvals <- seq(5,30,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
text(10,80,sprintf("Volume = %s + %s*Girth",coefficients(model1)[1],coefficients(model1)[2]))
#########
# visualize the results!
xvals <- seq(5,30,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
text(10,80,sprintf("Volume = %s + %s*Girth",round(coefficients(model1)[1],1),round(coefficients(model1)[2],1)))
model1$coefficients
model1$effects
model1$rank
model1$xlevels
model1$qr
pval(model1)
model1
summary(model1)
a <- summary(model1)
a$coefficients
a$coefficients[,"Pr(>|t|)"]
a$coefficients[,"Pr(>|t|)"][2]
summary(model1)$coefficients[,"Pr(>|t|)"][2]
#########
# visualize the results!
xvals <- seq(5,30,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
text(10,80,sprintf("Volume = %s + %s*Girth",round(coefficients(model1)[1],1),round(coefficients(model1)[2],1)))
text(10,65,sprintf("p = %s",summary(model1)$coefficients[,"Pr(>|t|)"][2])))
#########
# visualize the results!
xvals <- seq(5,30,0.5)
pred <- predict(model1,newdata=data.frame(Girth=xvals),interval = "confidence",level = 0.99)
plot(trees$Volume~trees$Girth,xlab="Girth (inches)",ylab="Volume (cubic feet)",main="Black Cherry",
xlim=range(xvals),ylim=c(0,100))
abline(model1,lwd=2,col="green")
lines(xvals,pred[,"upr"],col="green",lty=2)
lines(xvals,pred[,"lwr"],col="green",lty=2)
text(10,80,sprintf("Volume = %s + %s*Girth",round(coefficients(model1)[1],1),round(coefficients(model1)[2],1)))
text(10,65,sprintf("p = %s",round(summary(model1)$coefficients[,"Pr(>|t|)"][2],3)))
summary(model1)$coefficients[,"Pr(>|t|)"][2]
rmd2rscript2("module1_1.Rmd")
