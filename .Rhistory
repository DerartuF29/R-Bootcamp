ylab="Sepal length", las=1)
# First legend
legend("topleft", pch=19, col=plot.colors, legend=unique(iris$Species))
# Second plot
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Iris sepal length vs. petal length",
xlab="Petal length", ylab="Sepal length", las=1)
# Second legend
# The bty="n" argument suppresses the border around the legend. (A personal preference)
legend("topleft", pch=19, col=plot.colors,
legend=c("I. setosa", "I. versicolor", "I. virginica"), bty="n")
# Plot Three
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Iris sepal length vs. petal length",
xlab="Petal length", ylab="Sepal length", las=1)
#Legend tree with Italics
legend("topleft", pch=19, col=plot.colors,
legend=c("I. setosa", "I. versicolor", "I. virginica"),
bty="n", text.font=3)
## calculate the mean Sepal Length of for each species
bar.heights <- tapply(iris$Sepal.Length, iris$Species, mean)   #use "tapply()" function
# The basic 'barplot()' function
barplot(bar.heights)
# Let's add some flair
barplot(bar.heights, names.arg=c("I. setosa", "I. versicolor", "I. virginica"),
las=1, col=adjustcolor(plot.colors, alpha.f=0.5),
main="Sepal length for 3 Irises", ylab="Sepal length (cm)")
CI <- 2 * by(iris$Sepal.Length, iris$Species, sd)
lwr <- bar.heights - CI
upr <- bar.heights + CI
# I used the ylim= argument to pass a 2-element numeric vector specifying the y extent of the barplot. I added some extra room on the top to account for error bars.
# Importantly, assign the barplot to an object. I called it 'b' but you can call it whatever you like.
b <- barplot(bar.heights,
names.arg=c("I. setosa", "I. versicolor", "I. virginica"),
las=1, ylim=c(0,8), col=adjustcolor(plot.colors, alpha.f=0.5),
main="Sepal length for 3 Irises", ylab="Sepal length (cm)")
# Specify where each arrow starts (x0= and y0=) and ends (x1= and y1=)
arrows(x0=b, x1=b, y0=lwr, y1=upr, code=3, angle=90, length=0.1)
# ?arrows
layout(matrix(1:2, 1, 2))
## y-axis is in counts
hist(iris$Sepal.Length, main="Histogram of Sepal Length",
xlab = "Sepal Length")
## change y-axis to proportions using freq=FALSE
hist(iris$Sepal.Length, freq=FALSE, main="Histogram of Sepal Length",
xlab = "Sepal Length")
## Add a density estimator
lines(density(iris$Sepal.Length))   # add a line to the histogram to approximate the probability density of the data distribution
pairs(iris)
?ToothGrowth
head(ToothGrowth)
prop <- c(0.18, 0.25, 0.13, 0.05)
asympLCL <- c(0.14, 0.20, 0.11, 0.035)
asympUCL <- c(0.24, 0.33, 0.18, 0.09)
set.seed(13)
n <- 20 # Number of experimental trials
a <- 12
b <- 1.5
rings <- round(runif(n)*50)  # number of bell rings
wings <- round(a + b*rings + rnorm(n, sd=5))       # number of angels who get their wings
offset <- rpois(n, lambda=10)           # measurement error
lwr <- wings - offset
upr <- wings + offset
####################
# STATISTICS!
####################
#####
#####  Load Data
#####
sculpin.df <- read.csv("sculpineggs.csv")
head(sculpin.df)
summary(sculpin.df) # provides a set of summary statistics for data frame.
#####
#####  Summary Statistics
#####
mean(sculpin.df$NUMEGGS)      # compute sample mean
median(sculpin.df$NUMEGGS)    # compute sample median
min(sculpin.df$NUMEGGS)       # sample minimum
max(sculpin.df$NUMEGGS)       # sample maximum
range(sculpin.df$NUMEGGS)     # both min and max.
quantile(sculpin.df$NUMEGGS,0.5)            # compute sample median using quantile function
quantile(sculpin.df$NUMEGGS,c(0.25,0.75))   # compute sample quartiles
var(sculpin.df$NUMEGGS)           # sample variance
sd(sculpin.df$NUMEGGS)            # sample standard deviation
sd(sculpin.df$NUMEGGS)^2          # another way to compute variance
var(sculpin.df$NUMEGGS)^0.5       # another way to compute std. dev.
colMeans(sculpin.df)           # column mean of data frame
apply(sculpin.df,2,mean)       # column mean of data frame   # note the use of the "apply()" function.
apply(sculpin.df,2,median)     # column median of data frame
###########
# Deal with missing data
newdf <- read.table(file="data_missing.txt", sep="\t", header=T)  # load dataset with missing data
mean(newdf$Export)
mean(newdf$Export,na.rm = TRUE)
#####
#####  Plot data
#####
hist(sculpin.df$NUMEGGS)
plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)
#####
#####  Linear Regression
#####
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)      # fit linear regression model
m1                                      # view estimates of intercept and slope
summary(m1)                             # view summary of fit
summary(m1)$r.squared                   # extract R-squared
confint(m1)                             # confidence intervals for intercept and slope
AIC(m1)                                 # report AIC
plot(x = sculpin.df$FEMWT,y = sculpin.df$NUMEGGS)    # plot data
abline(m1)                                           # plot line of best fit
FEMWT.pred <- data.frame(FEMWT = 30)                   # create new data frame to predict number of eggs at FEMWT of 30
predict(m1,newdata=FEMWT.pred)                         # make prediction
predict(m1,newdata=FEMWT.pred,interval="confidence")   # make prediction and get confidence interval
predict(m1,newdata=FEMWT.pred,interval="prediction")   # make prediction and get prediction interval
##########
#  Explore the use of the "I()" syntax to interpret mathematical expressions literally within formulas.
mod_noI <- lm(NUMEGGS ~ FEMWT^2, data=sculpin.df)                  # fit linear regression model
summary(mod_noI)
mod_withI <- lm(NUMEGGS ~ I(FEMWT^2), data=sculpin.df)                  # fit linear regression model
summary(mod_withI)
m1
########################
####  More examples ####
########################
## Work through these examples and make sure you understand them before moving on to the challenge exercises.
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ I(FEMWT^0.5), data=sculpin.df)           # fit linear regression with intercept and sqrt of FEMWT term
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
#########
#  Here's a flexible method for drawing any arbitrary non-linear relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred)             # make prediction using "predict()" function
points(FEMWT.pred$FEMWT,NUMEGGS.pred,col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
#Compare models using AIC and R-squared
AIC(m1)
AIC(m2)
AIC(m3)
summary(m1)$r.squared
summary(m2)$r.squared
summary(m3)$r.squared
#Compare models using AIC and R-squared
AIC(m1)
AIC(m2)
AIC(m3)
#Compare models using AIC and R-squared
AIC(m1)
AIC(m3)
AIC(m1)
AIC(m2)
AIC(m3)
?predict.lm
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
NUMEGGS.confint
points(FEMWT.pred$FEMWT,NUMEGGS.confint$fit ,col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint$fit ,col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
NUMEGGS.confint[,"fit"]
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
########################
####  More examples ####
########################
## Work through these examples and make sure you understand them before moving on to the challenge exercises.
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ I(FEMWT^0.5), data=sculpin.df)           # fit linear regression with intercept and sqrt of FEMWT term
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
#########
#  Here's a flexible method for drawing any arbitrary non-linear relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred)             # make prediction using "predict()" function
points(FEMWT.pred$FEMWT,NUMEGGS.pred,col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
#Compare models using AIC and R-squared
AIC(m1)
AIC(m2)
AIC(m3)
summary(m1)$r.squared
summary(m2)$r.squared
summary(m3)$r.squared
#########
#  And finally, here's how you can draw a confidence interval or prediction interval around a regression relationship!
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
?mode
newdf <- read.table(file="data_missing.txt", sep="\t", header=T)
?mlv   # learn more about the function for computing the mode. Who knew there were so many methods for computing the mode?
# lets find the most frequent value(s) in the "Export" column:
mlv(newdf$Export, method="mfv", na.rm = T)
library(help = "modeest")    # get overview of package
library(modeest)    # load the package: This is package 'modeest' written by P. PONCET.
newdf <- read.table(file="data_missing.txt", sep="\t", header=T)
?mlv   # learn more about the function for computing the mode. Who knew there were so many methods for computing the mode?
# lets find the most frequent value(s) in the "Export" column:
mlv(newdf$Export, method="mfv", na.rm = T)
# Use layout to define a 2 row x 2 column matrix with elements 1, 1, 2, and 3.
# This divides the image into four sections but fills the first two sections
# with the first plot and then fills these next two sections with the final two plots
layout(matrix(c(1, 1, 2, 3), nrow=2, ncol=2))
# col: select a color for the plotting characters
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col="blue")
# We can use the c() function to make a vector and have several colors, plotting characters, etc. per plot.
# We start with alternating colors for each point
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col=c("black", "blue"))
# And we can also alternate the plotting symbol at each point.
plot(x=trees$Girth, y=trees$Volume, pch=c(1,19),
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1, col="blue")
?iris
?layout
# ?legend
layout(matrix(1:3, widths=1, heights=3))
# ?legend
layout(matrix(1:3, nrow=1, ncol=3))
# Plot
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Iris sepal length vs. petal length", xlab="Petal length",
ylab="Sepal length", las=1)
# First legend
legend("topleft", pch=19, col=plot.colors, legend=unique(iris$Species))
# Second plot
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Iris sepal length vs. petal length",
xlab="Petal length", ylab="Sepal length", las=1)
# Second legend
# The bty="n" argument suppresses the border around the legend. (A personal preference)
legend("topleft", pch=19, col=plot.colors,
legend=c("I. setosa", "I. versicolor", "I. virginica"), bty="n")
# Plot Three
plot(x=iris$Petal.Length, y=iris$Sepal.Length, pch=19, col=color.vector,
main="Iris sepal length vs. petal length",
xlab="Petal length", ylab="Sepal length", las=1)
#Legend tree with Italics
legend("topleft", pch=19, col=plot.colors,
legend=c("I. setosa", "I. versicolor", "I. virginica"),
bty="n", text.font=3)
?tapply
## calculate the mean Sepal Length of for each species
bar.heights <- tapply(X=iris$Sepal.Length, INDEX=iris$Species, FUN=mean)   #use "tapply()" function, which summarizes a numeric variable by levels of a categorical variable)
# The basic 'barplot()' function
barplot(bar.heights)
# Let's add some flair
barplot(bar.heights, names.arg=c("I. setosa", "I. versicolor", "I. virginica"),
las=1, col=adjustcolor(plot.colors, alpha.f=0.5),
main="Sepal length for 3 Irises", ylab="Sepal length (cm)")
?summary
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)      # fit linear regression model
m1                                      # view estimates of intercept and slope
summary(m1)                             # view summary of fit
summary(m1)$r.squared                   # extract R-squared
confint(m1)                             # confidence intervals for intercept and slope
AIC(m1)
FEMWT.pred <- data.frame(FEMWT = 30)
##################################
####  Model selection example ####
##################################
## Try to work through these examples and make sure you understand them before moving on to the challenge exercises.
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ I(FEMWT^0.5), data=sculpin.df)           # fit linear regression with intercept and sqrt of FEMWT term
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
#########
#  Here's a flexible method for drawing any arbitrary non-linear relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred)             # make prediction using "predict()" function
points(FEMWT.pred$FEMWT,NUMEGGS.pred,col="green",typ="l")  # plot sqrt model (note the use of the "points()" function to draw a line!)
#Compare models using AIC and R-squared
AIC(m1)
AIC(m2)
AIC(m3)
summary(m1)$r.squared
summary(m2)$r.squared
summary(m3)$r.squared
#########
#  And finally, here's how you can draw a confidence interval or prediction interval around a regression relationship!
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
3f <- "hell"
data.df[,2]=74
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 2                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
#########################
####  Managing data  ####
#########################
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will probably differ from yours!
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# ?read.csv
# ?readLines
# read.table with tab delimited file (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.tab.df <- read.table("data2.txt", header=TRUE)
head(data.tab.df)    # display the first few lines of the data frame
# read.table to import textfile
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# ?names: lists names of an object (columns, name of list elements)
names(data.csv.df)
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove objects we won't be using
rm(data.tab.df)
rm(data.txt.df)
rm(data.csv.df)
########
# Import data from the internet directly
brain.df <- read.table("http://www.oup.com/us/static/companion.websites/9780195089653/Spreadsheets/brainbody.csv", header=T, sep=",")
head(brain.df)
dim(brain.df)
# read built-in data on the passengers of the titanic
data(Titanic)
str(Titanic)    # examine the structure of this data object
####
#### Check/explore data object
####
# ?class: tells you what type of object you have
class(data.df)
# ?str: displays the internal structure of the object
str(data.df)
# ?head: displays first n elements of object (default=6)
head(data.df)
head(data.df,2)
# ?tail: displays last n elements of object (default=6)
tail(data.df)
####
#### Exporting data (save to hard drive as data file)
####
# ?write.table: writes a file to the working directory
# ?writeLines: writes to a file, one line at a time
write.table(data.df[,c("Country","Export")], file="data_export.csv", sep=",", col.names=TRUE, row.names=FALSE)   # export a subset of the data we just read in.
####
####  Saving and loading
####
# ?save: saves particular objects to hard disk
a <- 1
b <- data.df$Product
save(a,b,file="Module1_2.RData")
rm(a,b)   # remove these objects from the workspace
load("Module1_2.RData")   # load these objects back in!
save.image(file="Module2.RData")    # ?save.image: saves entire workspace
load(file="Module2.RData")  # load the workspace from the working directory
##############
# Clear the workspace (and load it back in!)
save.image(file="Module2.RData")    # ?save.image: saves entire workspace (we don't necessarily want to clear everything right now)
rm(list=ls())   # clear the entire workspace. Confirm that your workspace is now empty!
load(file="Module2.RData")   # load the objects back!
# <- assignment operator: required for functions
# =  alternative assignment operator
a <- 3     # assign the value "3" to the object "a"
a = 3      # assign the value "3" to the object "a"
a == 3     # answer the question: "does the object "a" equal "3"?
a == 2
data.df[,2]=74
data.df[,2]
1
newmat <- array(c(1:9),dim=c(3,3,3))
newmat
newmat[1,1,]
class(newmat)
class(newmat[1,1,])
class(newmat[1,1,,drop=FALSE])
newmat[1,1,,drop=FALSE]
newmat[1,1,]
newmat <- array(c(1:9),dim=c(3,3,3))
class(newmat)
newmat[1,1,]
class(newmat[1,1,])    # what? why is it no longer an array????
newmat[1,1,,drop=FALSE]
class(newmat[1,1,,drop=FALSE])    # ahhh, now we retain an
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
rmd2rscript("module1_4.Rmd")
rmd2rscript("module2_1.Rmd")
rmd2rscript("module2_2.Rmd")
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_2.Rmd",rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmarkdown::render("module1_2.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_3.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module1_4.Rmd",rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render("module1_4.Rmd",rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render("module1_4.Rmd",rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render("module1_4.Rmd",rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render("module1_4.Rmd",rmarkdown::pdf_document())  # latex_engine="xelatex"
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_2.Rmd")
