#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
rmd2rscript("module2_1.Rmd")
rmd2rscript("module2_2.Rmd")
rmd2rscript("module2_3.Rmd")
rmd2rscript("module2_4.Rmd")
rmd2rscript2("module2_5.Rmd")
rmd2rscript2("module2_6.Rmd")
rmd2rscript("module2_3.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
options(knitr.duplicate.label = 'allow')
##################################################
####                                          ####
####  R Bootcamp #2, Module 3                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
##################################################
####  Parallel processing in R                ####
####  Facilitator: Jonathan Greenberg         ####
####     jgreenberg@unr.edu                   ####
##################################################
data(geneData, package = "Biobase")   # load example data from Biobase package between all pairs of genes across all samples.
# This data represents 500 genes (organized by rows)
# with expression data (numerical).
# The goal is to calculate the correlation coefficient
# between all pairs of genes across all samples.  For example,
# to test gene 12 vs 13:
plot(geneData[12,],geneData[13,])    # plot the correlation between two genes
cor(geneData[12,],geneData[13,])
pair <- combn(1:nrow(geneData),2,simplify=F)   #leave this as a list, for now...
length(pair)
head(pair,n=3)     # note that the "head()" and "tail()" functions can be used on lists in addition to data frames...
tail(pair,n=3)
############
# New function: accepts a gene pair and the database as arguments and returns
# the correlation:
geneCor <- function(pair,gene=geneData){
cor(gene[pair[1],],gene[pair[2],])
}
# Test the function:
cor(geneData[12,],geneData[13,])
geneCor(pair=c(12,13),gene=geneData)    # should be the same result as the previous command...
########
# use "lapply" to run our function on the first three gene pairs
pair[1:3]
outcor <- lapply(pair[1:3],geneCor)
outcor
#################
# Examine processor use and speed
# First, open your task manager to view processor usage (see website for more details).
system.time(outcor <- lapply(pair,geneCor))
# Notice ONE CPU spiked.  Make note of how long it took to run.
fakeData <- cbind(geneData,geneData,geneData,geneData)    # make an even bigger dataset!
###########
# New, more complex function that generates bootstrap confidence intervals for correlation coefficients
library(boot)   # load the "boot" library for performing bootstrapping analysis
# 'x' represents vector with two elements, indicating the pair of genes to compare
# 'gene' represents a gene expression database
geneCor2 <- function(x, gene = fakeData){
mydata <- cbind(gene[x[1], ], gene[x[2], ])      # extract the rows (genes) to compare
mycor <- function(x, i) cor(x[i,1], x[i,2])     # function (correlation) to perform bootstrap analysis with
boot.out <- boot(mydata, mycor, 1000)           # perform bootstrap analysis (1000 iterations)
boot.ci(boot.out, type = "bca")$bca[4:5]         # extract and return the bootstrap confidence interval
}
# Test how long 10 pairs would take:
genCor2_system_time <- system.time(outcor <- lapply(pair[1:10],geneCor2))
genCor2_system_time["elapsed"]
length(pair)   # how many pairs were there again?
############
# estimate time to run 124,750 pairs
genCor2_system_time["elapsed"]      # time it took to run 10 pairs, in seconds
genCor2_system_time["elapsed"] *(124750/10)     # time it would take to run 124750 pairs, in seconds
genCor2_system_time["elapsed"] *(124750/10/60/60)    # in hours...
###########
# Explore parallel processing vs sequential processing
pair2 <- sample(pair,300)    # first extract a subsamble of all the pairs
# Let's test a sequential version of this:
system.time(outcor <- lapply(pair2,geneCor2))
###########
# Run this operation in parallel!!
### parallel: built-in parallel computation package.
library("parallel")       # load the package (comes with basic R installation)
install.packages("future")    # install "future" package, which we will use later
library("future")
########
# Make a cluster
myCluster <- parallel::makeCluster(spec=4,type="PSOCK")    # make cluster with 4 cpus of type "PSOCK"
myCluster
length(myCluster) # One entry per "worker".
myCluster[[1]]    # more info about this "worker"
date()    # run the "date()" function
workerDates <- parallel::clusterCall(cl=myCluster,fun=date)    # now try running the "date()" function on all clusters
class(workerDates)
length(workerDates) # One list element per worker.
####
# explore packages loaded in our worker environments
search()
workerPackages <- parallel::clusterCall(cl=myCluster,fun=search)
# workerPackages
####
# explore packages loaded in our worker environments
search()      # packages loaded in global environment
workerPackages <- parallel::clusterCall(cl=myCluster,fun=search)     # .. and worker environments
# workerPackages
loadOnCls <- parallel::clusterEvalQ(cl=myCluster,library("boot"))
loadData <- parallel::clusterExport(cl=myCluster,"fakeData")
#######
# Call the "geneCor2()" function for each gene pair, using parallel processing
system.time(outcor2 <- parallel::clusterApplyLB(cl=myCluster,pair2,geneCor2))
# vs the non-clustered version:
system.time(outcor <- lapply(pair2,geneCor2))   # takes much longer!
library("foreach")
library("doParallel")
# sequential mode:
registerDoSEQ() # Avoids warnings
system.time(
outcor <- foreach(
p = pair2,
.packages="boot",
.combine="rbind") %dopar% {
return(geneCor2(p))
}
)
myCluster
# Register the backend with foreach (doParallel):
registerDoParallel(myCluster)
# Run our code! Notice I didn't change the foreach call at all:
system.time(
outcor <- foreach(
p = pair2,
.packages="boot",
.combine="rbind") %dopar% {
return(geneCor2(p))
}
)
geneCor2
?foreach
# Register the backend with foreach (doParallel):
registerDoParallel(myCluster)
# Run our code! Notice I didn't change the foreach call at all:
system.time(
outcor <- foreach(
p = pair2,
.packages="boot",
.export="geneCor2",
.combine="rbind") %dopar% {
return(geneCor2(p))
}
)
# Register the backend with foreach (doParallel):
registerDoParallel(myCluster)
# Run our code! Notice I didn't change the foreach call at all:
system.time(
outcor <- foreach(
p = pair2,
.packages="boot",
.export=c("geneCor2"),
.combine="rbind") %dopar% {
return(geneCor2(p))
}
)
parallel::clusterEvalQ(cl=myCluster,ls())
parallel::clusterCall(cl=myCluster,fun=search)
loadData <- parallel::clusterExport(cl=myCluster,"geneCor2")
parallel::clusterEvalQ(cl=myCluster,ls())
# Register the backend with foreach (doParallel):
registerDoParallel(myCluster)
# Run our code! Notice I didn't change the foreach call at all:
system.time(
outcor <- foreach(
p = pair2,
.packages="boot",
.export=c("geneCor2"),
.combine="rbind") %dopar% {
return(geneCor2(p))
}
)
rmd2rscript("module2_3.Rmd")
tribble
tibble
library(tidyverse)
library(tidyverse)
tibble
tribble
?tribble
rmd2rscript2("module2_6.Rmd")
search()
rmd2rscript("module2_4.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_4.Rmd")
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_1.Rmd")
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# ?read.csv
# ?readLines
# read.table with tab delimited file (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.tab.df <- read.table("data.dat", header=TRUE, sep="")
head(data.tab.df)    # display the first few lines of the data frame
# read.table to import textfile
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# ?names: lists names of an object (columns, name of list elements)
names(data.csv.df)
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove objects we won't be using
rm(data.tab.df)
rm(data.txt.df)
rm(data.csv.df)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp #1, Module 2                 ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
## NOTE: this module borrows heavily from an R short course developed by a team at Colorado State University.
# Thanks to Perry Williams for allowing us to use these materials!!
#########################
####  Managing data  ####
#########################
# Find the directory you're working in
getwd()          # note: the results from running this command on my machine will probably differ from yours!
####
####  Import data files into R
####
# ?read.table    # some useful functions for reading in data
# ?read.csv
# ?readLines
# read.table with tab delimited file (default is sep = "" (one of several common delimiters, including any type of whitespace))
data.tab.df <- read.table("data.dat", header=TRUE, sep="")
head(data.tab.df)    # display the first few lines of the data frame
# read.table to import textfile
data.txt.df <- read.table("data.txt", header=T, sep="")
# read.table with csv file
data.csv.df <- read.table("data.csv", header=T, sep=",")
# ?names: lists names of an object (columns, name of list elements)
names(data.csv.df)
# built-in default for importing from CSV (easiest and most widely used)
data.df <- read.csv("data.csv")
names(data.df)
# Remove objects we won't be using
rm(data.tab.df)
rm(data.txt.df)
rm(data.csv.df)
# read built-in data on the passengers of the titanic
data(Titanic)
str(Titanic)    # examine the structure of this data object
####
#### Check/explore data object
####
# ?class: tells you what type of data object you have
class(data.df)
# ?str: displays the internal structure of the data object
str(data.df)
# ?head: displays first n elements of object (default=6)
head(data.df)
head(data.df,2)
# ?tail: displays last n elements of object (default=6)
tail(data.df)
####
#### Exporting data (save to hard drive as data file)
####
# ?write.table: writes a file to the working directory
# ?writeLines: writes to a file, one line at a time
write.table(data.df[,c("Country","Export")], file="data_export.csv", sep=",", col.names=TRUE, row.names=FALSE)   # export a subset of the data we just read in.
####
####  Saving and loading
####
# ?save: saves particular objects to hard disk
a <- 1
b <- data.df$Product
save(a,b,file="Module1_2.RData")
rm(a,b)   # remove these objects from the workspace
load("Module1_2.RData")   # load these objects back in!
save.image(file="Module2.RData")    # ?save.image: saves entire workspace
load(file="Module2.RData")  # load the workspace from the working directory
##############
# Clear the workspace (and load it back in!)
save.image(file="Module2.RData")    # ?save.image: saves entire workspace (we don't necessarily want to clear everything right now)
rm(list=ls())   # clear the entire workspace. Confirm that your workspace is now empty!
load(file="Module2.RData")   # load the objects back!
# <- assignment operator: required for functions
# =  alternative assignment operator
a <- 3     # assign the value "3" to the object "a"
a = 3      # assign the value "3" to the object "a"
a == 3     # answer the question: "does the object "a" equal "3"?
a == 2
####
####  Boolean operations
####
#####
# Basic operators
# <    less than
# >    greater than
# <=   less than or equal to
# >=   greater than or equal to
# ==   equal to
# !=   not equal to
# %in% matches one of a specified group of possibilities
#####
# Combining multiple conditions
# &    must meet both conditions (AND operator)
# |    must meet one of two conditions (OR operator)
Y <- 4
Z <- 6
Y == Z  #I am asking if Y is equal to Z, and it will return FALSE
Y < Z
# Wrong!
data.df[,2]=74     # sets entire second column equal to 74!
data.df <- read.csv("data.csv")  ## correct our mistake in the previous line and revert to the original data!
# Right
data.df[,2]==74    # tests each element of column to see whether it is equal to 74
####
####  Subsetting data
####
##########
# The "which()" function -- return indices of a vector that meet a certain condition (condition is TRUE)
which(data.df[,2]==74)       # elements of the data column that are equal to 74
which(data.df[,2]!=74)       # elements of the data column that are NOT equal to 74
which(data.df[,2]<74)        #  and so on...
which((data.df[,2]<74)|(data.df[,2]==91))   # use the OR operator
data.df[which(data.df[,2]<74),2]    # check to make sure these numbers are under 74- they had better be!
data.df[data.df[,2]<74,2]    # alternative syntax without using "which()"...
sub.countries<-c("Chile","Colombia","Mexico")    # create vector of character strings
which(data.df[,1]=="Chile")
which(data.df$Country=="Chile")
# This command doesn't work because sub.countries is a vector, not a single character string.
which (data.df[,1]==sub.countries)
# Instead we use %in%
which(data.df[,1] %in% sub.countries)     # elements of data column that match one or more of the elements in "sub.countries"
which((data.df[,1] %in% sub.countries) & (data.df[,4]=="N"))   # use AND operator
which((data.df$Country %in% sub.countries) & (data.df$Product=="N"))
# What if we don't want the row number, but the actual row(s) of data that meet a particular condition?
data.df[which(data.df$Country %in% sub.countries),]
####
####  Practice subsetting a data frame
####
turtles.df <- read.table(file="turtle_data.txt", header=T, stringsAsFactors = FALSE)
names(turtles.df)
head(turtles.df)
# Subset for females
fem.turtles.df <- turtles.df[which(turtles.df$sex =="female"),]
# Can subset just one factor based on another
# Here we want to know the mean weight of all females
mean(fem.turtles.df$weight)
mean(turtles.df$weight[which(turtles.df$sex =="female")])
# Using subset to correct data entry problems
unique(turtles.df$sex)
table(turtles.df$sex)   # do you notice the data entry problem here?
turtles.df[which(turtles.df$sex=="fem"),2]<-"female"            # recode the sex variable
# Try using the "subset()" function, which can make subsetting a data frame even easier!
female.turtles <- subset(turtles.df,sex=="female")              # use the "subset()" function!
female.turtles <- subset(turtles.df,sex!="male")                # alternative
female.turtles <- turtles.df[which(turtles.df$sex!="male"),]    # alternative
subset.turtles.df <- subset(turtles.df, weight >= 10)
head(subset.turtles.df)
# Subsetting to certain individuals
bad.tags <- c(13,105)
good.turtles.df <- turtles.df[!(turtles.df$tag_number %in% bad.tags),]
bad.turtles.df <- turtles.df[turtles.df$tag_number %in% bad.tags,]
bad.turtles.df
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
2L
typeof(2L)
typeof(2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
d.mat <- rbind(c(1,2,3),c(4,5,6))        # create matrix another way
d.mat
d.mat <- matrix(c(1,2,3,4,5,6),nrow=3,ncol=2,byrow=T)        # create matrix another way
d.mat
d.mat <- matrix(c(1,2,3,4,5,6),nrow=3,ncol=2)        # create matrix another way
d.mat
d.mat <- rbind(c(1,2,3),c(4,5,6))        # create matrix another way
d.mat
d.mat + 2
d.mat/sum(d.mat)
d.mat <- rbind(c(1,4),c(2,5),c(3,6))        # create matrix another way
d.mat
knitr::opts_chunk$set(echo = TRUE)
rmarkdown::render("module1_1.Rmd",rmarkdown::pdf_document())
install.packages("RevoUtilsMath")
