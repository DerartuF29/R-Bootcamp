####
####  Subsetting data
####
##########
# The "which()" function -- return indices of a vector that meet a certain condition (condition is TRUE)
which(data.df[,2]==74)       # elements of the data column that are equal to 74
which(data.df[,2]!=74)       # elements of the data column that are NOT equal to 74
which(data.df[,2]<74)        #  and so on...
which((data.df[,2]<74)|(data.df[,2]==91))   # use the OR operator
data.df[which(data.df[,2]<74),2]    # check to make sure these numbers are under 74- they had better be!
data.df[data.df[,2]<74,2]    # alternative form without using "which()"...
sub.countries<-c("Chile","Colombia","Mexico")    # create vector of character strings
which(data.df[,1]=="Chile")
which(data.df$Country=="Chile")
# This command doesn't work because sub.countries is a vector, not a single character string.
which (data.df[,1]==sub.countries)
####
####  Practice subsetting a data frame
####
turtles.df <- read.table(file="turtle_data.txt", header=T, stringsAsFactors = FALSE)
names(turtles.df)
head(turtles.df)
# Subset for females
fem.turtles.df <- turtles.df[which(turtles.df$sex =="female"),]
# Can subset just one factor based on another
# Here we want to know the mean weight of all females
mean(fem.turtles.df$weight)
mean(turtles.df$weight[which(turtles.df$sex =="female")])
# Using subset to correct data entry problems
unique(turtles.df$sex)
table(turtles.df$sex)
# Try using the "subset()" function, which can make subsetting a data frame even easier!
female.turtles <- subset(turtles.df,sex=="female")              # use the "subset()" function!
female.turtles <- subset(turtles.df,sex!="male")                # alternative
female.turtles <- turtles.df[which(turtles.df$sex!="male"),]    # alternative
turtles.df[which(turtles.df$sex=="fem"),2]<-"female"            # recode the
subset.turtles.df <- subset(turtles.df, weight >= 10)
head(subset.turtles.df)
# Subsetting to certain individuals
bad.tags <- c(13,105)
good.turtles.df <- turtles.df[!(turtles.df$tag_number %in% bad.tags),]
bad.turtles.df <- turtles.df[turtles.df$tag_number %in% bad.tags,]
bad.turtles.df
male_turtles <- turtles[,which(turtles$sex=="male")]
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
con3 <- file(outfile,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
rmd2rscript("module1_4.Rmd")
rmd2rscript("module2_1.Rmd")
help.start()
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
install.packages("modeest")    # run this if you haven't yet installed the package!
help.start(modeest)
help.start("modeest")
library(help = "modeest")
library(help = "modeest")
?library
library(help = "Hmisc")
library(help = "modeest")    # get overview of package
newdf <- read.table(file="data_missing.txt", sep="\t", header=T)
head(newdf)
newdf
# lets find the most frequent value in the "product" column:
mfv(newdf$Product)
library(modeest)    # load the package: This is package 'modeest' written by P. PONCET.
# lets find the most frequent value in the "product" column:
mfv(newdf$Product)
newdf$Product
?mfv
# lets find the most frequent value in the "Import" column:
mfv(newdf$Import)
mean(newdf$Export)
mean(newdf$Export,na.rm = TRUE)
?mlv
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Import, method="mfv")        # apparently there is a three-way tie for the mode!
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Import, method="mfv", na.rm = T)        # apparently there is a three-way tie for the mode!
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Import, method="mfv", na.rm = T)        # apparently there is a three-way tie for the mode!
newdf$Import
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Export, method="mfv", na.rm = T)        # apparently there is a three-way tie for the mode!
newdf$Export
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Import, method="mfv", na.rm = T)        # apparently there is a three-way tie for the mode!
newdf$Import
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Import, method="grenader", na.rm = T)        # apparently there is a three-way tie for the mode!
# lets find the most frequent value(s) in the "Import" column:
mlv(newdf$Export, method="mfv", na.rm = T)        # apparently there is a three-way tie for the mode!
install.packages("car")
library(car)
scatter3d(Bark~Food+Cars,surface=FALSE)
#########
# 3D Plotting example
#########
#########
# Data: dog barks per day (and two explanatory variables)
Cars= c(32, 28, 9, 41, 23, 26, 26, 31, 12, 25, 32, 13, 19, 19, 38,
36, 43, 26, 21, 15, 17, 12, 7, 41, 38, 33, 31, 9, 40, 21)
Food= c(0.328, 0.213, 0.344, 0.339, 0.440, 0.335, 0.167, 0.440, 0.328,
0.100, 0.381, 0.175, 0.238, 0.360, 0.146, 0.430, 0.446, 0.345,
0.199, 0.301, 0.417, 0.409, 0.142, 0.301, 0.305, 0.230, 0.118,
0.272, 0.098, 0.415)
Bark=c(15, 14, 6, 12, 8, 1, 9, 8, 1, 12, 14, 9, 8, 1, 19, 8, 13, 9,
15, 11, 8, 7, 8, 16, 15, 10, 15, 4, 17, 0)
scatter3d(Bark~Food+Cars,surface=FALSE)
scatter3d(Bark~Food+Cars,surface=TRUE)
car::scatter3d(Bark~Food+Cars,surface=TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
####
####  Functions
####
simple_function = function(){       # this function has no arguments
message <- "Hello, world!"
print(message)
}
####
####  Functions
####
my.function = function(){       # this function has no arguments
message <- "Hello, world!"
print(message)
}
my.function()
## We can write our own functions. Useful if we have to repeat operations over and over.
my.mean <- function(x){
sum(x)/length(x)
}
foo <- c(2, 4, 6, 8)
my.mean(foo)
## We can write our own functions. Useful if we have to repeat operations over and over.
my.mean <- function(x){
m <- sum(x)/length(x)
return(m)
}
foo <- c(2, 4, 6, 8)
my.mean(foo)
## A function to square the arguments.
square <- function(x){
x^2
}
## Square a single value (scaler).
square(2)
## Square a vector.
square(1:10)
## Often, we need to write functions that are not included in the base R package e.g., the logit function.
## Calculate the log-odds (logit).
logit <- function(x){
log(x/(1-x))
}
## Calculate logit of 0.9.
logit(.9)
## Often, we need to write functions that are not included in the base R package e.g., the logit function.
## Calculate the log-odds (logit).
logit <- function(x){
log(x/(1-x))
}
## Calculate logit of 0.9.
logit(.9)
## Sequence between 0 and 1.
x <- seq(from = 0, to = 1, by = 0.01)
## Caclulate the logit of a vector.
logit.x <- logit(x)
logit.x
## Plot x on x-axis, and logit(x) on y axis.
par(mfrow = c(1, 1))
plot(x, logit.x, type = 'l')    # View the output graphically.
## The expit (or inverse logit) funtion.
expit <- function(x){
exp(x)/(1+exp(x))
}
## Calculate the inverse-logit of logit(0.9) = 2.197225.
expit(2.197225)
expit.logit.x <- expit(logit.x)    # Return to original x values.
## Plot x on x-axis, and expit(logit(x)) = x on y axis.
plot(x, expit.logit.x, type = 'l')
x
## The expit (or inverse logit) funtion.
expit <- function(x){
exp(x)/(1+exp(x))
}
## Calculate the inverse-logit of logit(0.9) = 2.197225.
expit(2.197225)
expit.logit.x <- expit(logit.x)    # Return to original x values.
## Plot x on x-axis, and expit(logit(x)) = x on y axis.
plot(x, expit.logit.x, type = 'l')
## Plot "logistic" curve
plot(x=seq(-3,3,0.1),y=expit(x),type="l")
## The expit (or inverse logit) funtion.
expit <- function(x){
exp(x)/(1+exp(x))
}
## Calculate the inverse-logit of logit(0.9) = 2.197225.
expit(2.197225)
expit.logit.x <- expit(logit.x)    # Return to original x values.
## Plot x on x-axis, and expit(logit(x)) = x on y axis.
plot(x, expit.logit.x, type = 'l')
## Plot "logistic" curve
plot(x=seq(-3,3,0.1),y=expit(seq(-3,3,0.1)),type="l")
####
####  if...else statements
####
########
# Draw a sample from a Binomial distribution with p = 0.7.
n.samples <- 1
p <- 0.7
x <- rbinom(n = n.samples, size = 1, prob = p)
if (x > 0) {
print("Detected")
} else {
print("Not detected")
}
x
####
####  if...else statements
####
########
# Draw a sample from a Binomial distribution with p = 0.7.
n.samples <- 1
p <- 0.7
x <- rbinom(n = n.samples, size = 1, prob = p)
if (x > 0) {
print("Detected")
} else {
print("Not detected")
}
####
####  ifelse()
####
## Note if...else only works for testing one value. If we have a spreadsheet with lots of data, need something else.
n.samples <- 100
set.seed(2017)
## 100 samples from a binomial disribution with detection probability = p = 0.7.
y <- rbinom(n = n.samples, size = 1, prob = p)
y
## incorrect usage
if (y == 1) {
print("Detected")
} else {
print("Not detected")
}   # PRINTS A WARNING MESSAGE!
## Use ifelse instead.
detection.history <- ifelse(y == 1, print("Detected"), print("Not detected"))
detection.history
## Going the other direction.
ifelse(detection.history == "Detected", 1, 0)
xt  <-  cbind(rbinom(10, 1, .5), rbinom(10, 1, .6))
xt
ifelse(xt[, 1] > 0 & xt[, 2] > 0, print("Detected twice"),
print("Not detected twice"))
# closer look at iteration vector:
1:n.iter
####
####  for loops
####
n.iter <- 10
count <- 0
for(i in 1:n.iter){
count <- count+1            # assign a new value of count equal to the old value of count + 1
print(count)
}
# closer look at iteration vector:
1:n.iter
## Using the placeholder variable "i" within the for loop:
count <- 0
for(i in 1:n.iter){
count <- count+i            # assign a new value of count equal to the old value of count + i
print(count)
}
## A for-loop for dependent sequence
n.iter <- 10
x <- rep(0, n.iter)            # set up vector of all zeros
x[1] <- 1                     # assign x_1  <-  1
x[2] <- 1                     # assign x_2 = 0
x
## Fibonacci sequence
for(i in 3:n.iter){
x[i] <- x[i-1]+x[i-2]       # x_i = x_(i-1) + x_(i-2)
}
x
## Using the placeholder variable "i" within the for loop:
count <- 0
for(i in 1:n.iter){
count <- count+i            # assign a new value of count equal to the old value of count + i
print(count)
}
## A for-loop for dependent sequence (here, the Fibonacci sequence)
n.iter <- 10
x <- rep(0, n.iter)            # set up vector of all zeros
x[1] <- 1                     # assign x_1  <-  1
x[2] <- 1                     # assign x_2 = 0
x
for(i in 3:n.iter){
x[i] <- x[i-1]+x[i-2]       # x_i = x_(i-1) + x_(i-2)
}
x
################
#### GENERAL TIPS
################
#############
# 1. Use code examples provided by others
install.packages("dismo")     # install and load "dismo" for species distribution modeling
library(dismo)
vignette("dismo")      # pull up a helpful vignette, with useful code examples!
vignette(sdm,dismo)      # pull up a helpful vignette, with useful code examples!
vignette('dismo')      # pull up a helpful vignette, with useful code examples!
vignette('sdm','dismo')      # pull up a helpful vignette, with useful code examples!
vignette('sdm')      # pull up a helpful vignette, with useful code examples!
vignette(dismo')      # pull up a helpful vignette, with useful code examples!
vignette('dismo')      # pull up a helpful vignette, with useful code examples!
dismo::vignette('sdm')      # pull up a helpful vignette, with useful code examples!
vignette(dismo::bioclim()'sdm')      # pull up a helpful vignette, with useful code examples!
vignette(dismo::'sdm')      # pull up a helpful vignette, with useful code examples!
vignette('raster')      # pull up a helpful vignette, with useful code examples!
vignette('Raster')      # pull up a helpful vignette, with useful code examples!
vignette("modeest")
library(help = "raster")
library(help = "car")
vignette('Raster','raster')      # pull up a helpful vignette, with useful code examples!
library(help = "car")    # help file for the useful "car" package for applied regression
vignette('embedding','car')   # pull up the "embedding" vignette in the 'car' package
library(help = "car")    # help file for the useful "car" package for applied regression
example(lm)   # run examples for "lm" function (included in base R)
browseVignettes('car')
browseVignettes('car')
browseVignettes('car')
browseVignettes('dismo')
vignette('brt','dismo')
demo(package="stats")    # demo for package 'stats', which is included in base R
demo('nlm','stats')
help.start()
citation('car')
citation()    # and here's the citation for R in general- useful for when you use R for manuscripts!
library(help = "car")    # help file for the useful "car" package for applied regression
demo('nlm','stats')
rmd2rscript("module2_2.Rmd")
# install.packages("tidyverse")
library(tidyverse)
####
####  Import data as a Tibble dataframe and take a quick glance
####
# import meteorological data from Hungry Horse (HH) and Polson Kerr (PK) dams as tibble dataframe using readr
clim_data <- read_csv("MTMetStations.csv")
# display tibble - note nice formatting and variable info, entire dataset is not displayed as is case in read.csv
clim_data
# display the last few lines of the data frame
tail(clim_data)
####
####  Use Tidyr verbs to make data 'tidy'
####
# look at clim_data -- is it in tidy format? What do we need to do to get it there?
head(clim_data)
# gather column names into a new column called 'climvar_station', and all of the numeric precip and temp values into a column called 'value'. By including -Date, we indicate that we don't want to gather this column.
gather_clim_vars <- gather(clim_data,
key = climvar_station,
value = value,
-Date)
gather_clim_vars
# separate the climvar_station column into two separate columns that identify the climate variable and the station
separate_clim_vars <- gather_clim_vars %>%
separate(climvar_station,
into = c("Station","climvar"))
separate_clim_vars
# spread distributes the clim_var column into separate columns, with the data values from the 'value' column
tidy_clim_data <- spread(separate_clim_vars,
key = climvar,
value = value)
tidy_clim_data
# repeat above as single pipe series without creation of intermediate datasets
tidy_clim_data <- clim_data %>%
gather(key = climvar_station,
value = value,
-Date) %>%
separate(climvar_station,
into = c("Station","climvar")) %>%
spread(key = climvar,
value = value)
tidy_clim_data
rmd2rscript("module2_1.Rmd")
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
con3 <- file(outfile,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module2_1.Rmd")
rmd2rscript("module2_2.Rmd")
rmd2rscript("module2_1.Rmd")
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_4.Rmd")
rmd2rscript("module1_3.Rmd")
infile="module1_1.Rmd"
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
outfile1
outfile2
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
con3 <- file(outfile,"w")
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
rmd2rscript("module1_4.Rmd")
rmd2rscript("module2_1.Rmd")
rmd2rscript("module2_2.Rmd")
rmd2rscript("module2_1.Rmd")
rmd2rscript("module1_1.Rmd")
rmd2rscript("module1_2.Rmd")
rmd2rscript("module1_3.Rmd")
rmd2rscript("module1_4.Rmd")
rmd2rscript("module2_1.Rmd")
source('E:/GIT/R-Bootcamp/module2_1.R')
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
###########
# install package from GitHub:
# install.packages("devtools")    # run this if you haven't already installed the "devtools" package
library(devtools)
install_github("kbroman/broman")  # install a random package from GitHub!
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
layout(matrix(1:4, 2, 2))
# main: adds a title
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees")
# xlab: adds an x axis label
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)")
# ylab: adds a y axis label
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)")
# las: rotates axis labels; las=1 makes them all parallel to reading direction
plot(x=trees$Girth, y=trees$Volume, pch=19,
main="Girth vs. Volume for Black Cherry Trees",
xlab="Tree Girth (in)", ylab="Tree Volume (cu ft)",
las=1)
