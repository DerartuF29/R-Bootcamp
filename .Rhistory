str(cars)    # examine the structure of this data object
?cars        # learn more about this built-in data object
?mtcars        # learn more about this built-in data object
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_1.Rmd")
rmd2rscript2("module1_2.Rmd")
rmd2rscript2("module1_3.Rmd")
install.packages("rmarkdown")
library(knitr)
detach("package:knitr", unload = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
sculpin.df <- read.csv("sculpineggs.csv")
head(sculpin.df)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
##################################
####  Model selection example ####
##################################
## Try to work through these examples and make sure you understand them before moving on to the challenge exercises.
m1 <- lm(NUMEGGS ~ FEMWT, data=sculpin.df)                  # fit linear regression model
summary(m1)
m2 <- lm(NUMEGGS ~ 1, data=sculpin.df)                      # fit linear regression with intercept only (mean model)
summary(m2)
m3 <- lm(NUMEGGS ~ I(FEMWT^0.5), data=sculpin.df)           # fit linear regression with intercept and sqrt of FEMWT term
summary(m3)
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
abline(m1,col="black")                                     # plot line of best fit
abline(m2,col="red")                                       # plot intercept only model
#########
#  Here's a flexible method for drawing any arbitrary non-linear relationship!
FEMWT.pred <- data.frame(FEMWT = seq(10,45,by=0.1))        # create new data frame to predict number of eggs from FEMWT of 10 to 45 by increments of 0.1
NUMEGGS.pred <- predict(m3,newdata=FEMWT.pred)             # make prediction using "predict()" function
lines(FEMWT.pred$FEMWT,NUMEGGS.pred,col="green")  # plot sqrt model (note the use of the "points()" function to draw a line!)
########
# Perform model selection!
#Compare models using AIC
AIC(m1)
AIC(m2)
AIC(m3)
#Compare models using R-squared
summary(m1)$r.squared
summary(m2)$r.squared
summary(m3)$r.squared
#########
#  And finally, here's how you can draw a confidence interval or prediction interval around a regression relationship!
plot(NUMEGGS ~ FEMWT,data=sculpin.df)                      # plot data
NUMEGGS.confint <- predict(m3,newdata=FEMWT.pred,interval="prediction")             # use "predict()" function to compute the prediction interval!
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"fit"],col="green",typ="l",lwd=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"lwr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
points(FEMWT.pred$FEMWT,NUMEGGS.confint[,"upr"],col="green",typ="l",lty=2)  # plot fitted sqrt model
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript <- function(infile="module1_1.Rmd"){    # function for converting markdown to scripts
outfile1 <- gsub(".Rmd",".R",infile)
outfile2 <- gsub(".Rmd",".txt",infile)
close( file( outfile1, open="w" ) )   # clear output file
close( file( outfile2, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile1,"w")
con3 <- file(outfile2,"w")
stringToFind <- "```{r*"
isrblock <- FALSE
count=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
if(isrblock){
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if(count>1){
write(newline,file=con2,append=TRUE)
write(newline,file=con3,append=TRUE)
}
count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2 <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript2("module1_4.Rmd")
rmd2rscript2("module2_1.Rmd")
rmd2rscript2("module2_2.Rmd")
rmd2rscript2("module2_3.Rmd")
rmd2rscript2("module2_4.Rmd")
rmd2rscript2("module2_5.Rmd")
rmd2rscript2("module1_1.Rmd")
prob=0.75
prob/(1-prob)
log(prob/(1-prob))
qlogis(0.75)
plogis(1.0986)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
sample(0:50, 10, replace = TRUE)
logit(x)
logit.safe(x)
rmd2rscript2("module1_4.Rmd")
cbind(rbinom(10, 1, .5), rbinom(10, 1, .6))
knitr::opts_chunk$set(echo = TRUE)
rmd2rscript2("module2_2.Rmd")
rmarkdown::render("module2_2.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module2_3.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module2_3.Rmd",rmarkdown::pdf_document())
tinytex::reinstall_tinytex()
tinytex:::is_tinytex()
unlink('module2_3_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE)
rmarkdown::render("module2_3.Rmd",rmarkdown::pdf_document())
unlink('module2_4_cache', recursive = TRUE)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Biobase")
data(geneData, package = "Biobase")   # load example data from Biobase package between all pairs of genes across all samples.
rmarkdown::render("module2_4.Rmd",rmarkdown::pdf_document())
unlink('module2_5_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
file_name <- 'data.zip'
download.file(file_name, destfile = 'data.zip')
file_name <- 'https://kevintshoemaker.github.io/R-Bootcamp/data.zip'
download.file(file_name, destfile = 'data.zip')
## we can do this with other reprojections as well so you can really tell a difference
layout(matrix(1:8, nrow = 2))
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=aea') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
##################################################
####                                          ####
####  R Bootcamp, Module 2.5                  ####
####                                          ####
####   University of Nevada, Reno             ####
####                                          ####
##################################################
######################################################
####  Introduction to Spatial Data Analysis in R  ####
####     Facilitator: Mitch Gritts                ####
######################################################
###################
# before starting make sure we have a clean global environment
rm(list = ls())
# install.packages(c('dplyr', 'spData', 'sf', 'raster', 'rgdal', 'rgeos', 'rcartocolor', 'magrittr', 'leaflet'))   # run this line if you haven't already installed these packages!
file_name <- 'https://kevintshoemaker.github.io/R-Bootcamp/data.zip'
download.file(file_name, destfile = 'data.zip')
unzip(zipfile = 'data.zip', exdir = '.')
# load libraries and set working directory
library(dplyr)
library(spData)
library(sf)
library(raster)
library(rgdal)
library(rgeos)
library(rcartocolor)
library(magrittr)
library(leaflet)
## a single point
pt <- st_point(c(1, 1))
plot(pt)
## multiple points
mpt <- st_multipoint(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(0, 0)))
plot(mpt)
## a line
l <- st_linestring(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(0, 0)))
plot(l, col = 'purple')
## a polygon
poly <- st_polygon(list(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(0, 0))))
plot(poly, col = 'purple')
## ...etc, multiline and multipolygons
# create spatial points data frame ----
## load reptile data
reptiles <- readr::read_csv('reptiles.csv')
## create a SpatialPoints object
## provide data (x), the columns that contain the x & y (coords)
## and the coordinate reference system (crs)
sf_points <- st_as_sf(x = reptiles,
coords = c('x', 'y'),
crs = '+init=epsg:26911')
## inspect the SpatialPoints object
str(sf_points)
head(sf_points)
# subset an sf object ----
phpl <- sf_points[sf_points$species == 'Phrynosoma platyrhinos', ]
head(phpl)
## check to see that there is only one species in the data.frame
phpl %>% magrittr::extract2('species') %>% unique()
class(sf_points)
## we can filter using dplyr syntax
sf_points %>%
dplyr::filter(species == 'Phrynosoma platyrhinos') %>%
head()
## plot with sf::plot
plot(head(sf_points, n = 100))
plot(head(sf_points['year'], n = 100))
## the plot function also uses this syntax to select a single row to plot
## plot(head(sf_points['year'], n = 100))
## and if you don't want to color the plot by feature you can use 0
## to specify plotting 0 attributes
## note, this is plotting all the points
plot(sf_points[0], col = 'purple')
#############
# Nevada Counties example...
# read in nv county shapefile ----
counties <- st_read(dsn = 'data/nv_counties/NV_Admin_Counties.shp')
## once finished check the structure
str(counties, max.level = 3)
## some data management
### check the contents of the geometry field
counties$geometry
### let's double check that projection of the counties
st_crs(counties)
### How does this projection compare to the sf_points object?
### double check the sf_points projection
st_crs(sf_points)
### then explicitly compare them using boolean logic
st_crs(counties) == st_crs(sf_points)
### let's reproject the points to our desired CRS, utm
### we will go into more detail on reprojections later
counties <- st_transform(counties, st_crs(sf_points))
### double check they are equal
st_crs(counties) == st_crs(sf_points)
## plot a spatial polygon
plot(counties)
## we don't wan't to color by any feature
## st_geometry returns just the geometry column
plot(st_geometry(counties))
## we can plot certain polygons...
## which has a plotting behavior we aren't used to
## this will plot every attribute for the first county
plot(counties[1, ])
## if we only want to include the outline, the following will work
plot(st_geometry(counties)[1])
## multiple at once
layout(matrix(1:3, ncol = 3, nrow = 1))
plot(st_geometry(counties)[1])
plot(st_geometry(counties)[1:4])
plot(st_geometry(counties)[counties$CNTYNAME == 'Clark'])
## we can even plot our reptile points ontop of the counties
layout(matrix(1))
plot(st_geometry(counties))
plot(st_geometry(sf_points), pch = 1, cex = .5, col = 'purple', add = TRUE)
# Spatial joins ----
## use the %over% funcstion, which is the same as over(spdf_points, counties)
rslt <- st_join(sf_points, counties)
## what does rslt look like?
str(rslt)
## how about summary
summary(rslt)
# unioning polygons ----
## all of these function come from the rgeos package.
## select two counties to union
plot(st_geometry(counties)[2:3])
## union them
plot(st_union(st_geometry(counties)[2:3]))
# union all interior polygons ----
## we ccan do the same thing to get a the border of NV
## the following uses the pipe (%>%) to increase code readability
nv <- counties %>% st_geometry() %>% st_union()
plot(nv)
# topological relations ----
# create a polygon
a_poly = st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a = st_sfc(a_poly)
# create a line
l_line = st_linestring(x = matrix(c(-1, -1, -0.5, 1), ncol = 2))
l = st_sfc(l_line)
# create points
p_matrix = matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2)
p_multi = st_multipoint(x = p_matrix)
p = st_cast(st_sfc(p_multi), "POINT")
## plot
par(pty = "s")
plot(a, border = "red", col = "gray", axes = TRUE)
plot(l, add = TRUE)
plot(p, add = TRUE, lab = 1:4)
text(p_matrix[, 1] + 0.04, p_matrix[, 2] - 0.06, 1:4, cex = 1.3)
st_within(p[1], a, sparse = F)
st_within(p[2], a, sparse = F)
st_touches(p[2], a, sparse = F)
st_intersects(p[1:2], a, sparse = F)
st_intersects(p[3:4], a, sparse = F)
# remove points outside nv ----
plot(nv)
plot(st_geometry(sf_points), col = 'purple', add = T)
# remove points outside
sparse <- st_intersects(rslt, nv)
sel_logical <- lengths(sparse) > 0
sf_points <- rslt[sel_logical, ]
## check the results by uncommenting this code, and running
# plot(nv)
# plot(st_geometry(sf_points), col = 'purple', add = T)
# spTranform ----
## we will use a data set from the spData package
## the epsg id for this data is 4269
us_states <- spData::us_states
## check the CRS
st_crs(us_states)
plot(st_geometry(us_states),
col = 'white',
graticule = st_crs(us_states),
axes = T, main = 'Initial, EPSG = 4269')
## reproject basics, and replot
wgs_usa <- st_transform(us_states, crs = '+init=epsg:4326')
plot(st_geometry(wgs_usa),
col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'WGS84')
## we can do this with other reprojections as well so you can really tell a difference
layout(matrix(1:8, nrow = 2))
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=aea') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
st_crs(wgs_usa)
## we can do this with other reprojections as well so you can really tell a difference
layout(matrix(1:8, nrow = 2))
us_states
us_states %>% st_geometry()
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=aea')
us_states
st_transform(crs = '+proj=aea')
st_transform(us_states,crs = '+proj=aea')
st_transform(st_geometry(us_states),crs = '+proj=aea')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=sinu') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Van Der Grinten')
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea") %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
st_crs(wgs_usa)
plot(us_states)
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=sinu') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Van Der Grinten')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=robin') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Robinson')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=robin') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Robinson')
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea") %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
st_crs(us_states)
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea") %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea +lat_1=0.0 +lat_2=0.0" ) %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs" ) %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs" ) %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
## we can do this with other reprojections as well so you can really tell a difference
layout(matrix(1:8, nrow = 2))
us_states %>% st_geometry() %>%
st_transform(crs = "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs" ) %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Albers Equal Area')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=sinu') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Van Der Grinten')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=robin') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Robinson')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=gall') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Gall-Peters')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=eqc') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Plate Carree')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=goode') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Goode Homolosine')
us_states %>% st_geometry() %>%
st_transform(crs = '+init=epsg:26911') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'NAD83 Zone 11')
us_states %>% st_geometry() %>%
st_transform(crs = '+init=epsg:26921') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'NAD83 Zone 21')
## we can also define our own projection
layout(matrix(1:2, nrow = 2))
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=lcc') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Lambert Conformal Standard')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=lcc +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Lambert Conformal Standard')
us_states %>% st_geometry() %>%
st_transform(crs = '+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs') %>%
plot(col = 'white',
graticule = st_crs(wgs_usa),
axes = T, main = 'Lambert Conformal USA')
rmarkdown::render("module2_5.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module2_5.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module2_5.Rmd",rmarkdown::pdf_document())
rmarkdown::render("module2_5.Rmd",rmarkdown::pdf_document())
